#!/usr/bin/env bun

import { parseArgs } from "util";
import { z } from "zod";
import matter from "gray-matter";
import yaml from "js-yaml";
import { readdir, readFile, writeFile, mkdir, unlink } from "fs/promises";
import { existsSync } from "fs";
import { join, basename } from "path";

// Custom matter parser that disables automatic date conversion
// This ensures dates like "2026-01-12" stay as strings, not Date objects
const matterOptions = {
  engines: {
    yaml: (s: string) => yaml.load(s, { schema: yaml.JSON_SCHEMA }) as Record<string, unknown>,
  },
};

function parseFrontmatter(content: string) {
  return matter(content, matterOptions);
}

// ============================================================================
// Schema
// ============================================================================

const TaskSchema = z.object({
  id: z.string(),
  title: z.string(),
  status: z.enum(["inbox", "active", "blocked", "done", "cancelled"]),
  priority: z.enum(["P0", "P1", "P2", "P3"]),
  created: z.string(),
  updated: z.string(),
  due: z.string().nullable().optional(),
  done: z.string().nullable().optional(),
  archived: z.string().nullable().optional(),
  project: z.string().nullable().optional(),
  promoted_from: z.string().nullable().optional(),
  promoted_to: z.string().nullable().optional(),
  repo: z.string().nullable().optional(),
  team: z.string().nullable().optional(),
  owner: z.string().nullable().optional(),
  assignees: z.array(z.string()).optional().default([]),
  stakeholders: z.array(z.string()).optional().default([]),
  blocked_by: z.array(z.string()).optional().default([]),
  blocks: z.array(z.string()).optional().default([]),
  related: z.array(z.string()).optional().default([]),
  tags: z.array(z.string()).optional().default([]),
  effort: z.string().nullable().optional(),
  sprint: z.string().nullable().optional(),
  milestone: z.string().nullable().optional(),
  risk: z.enum(["low", "medium", "high"]).nullable().optional(),
}).passthrough();

type Task = z.infer<typeof TaskSchema>;

// ============================================================================
// Constants
// ============================================================================

const TASK_ARCHIVE_RETENTION_DAYS = 30;
const PROJECT_ARCHIVE_RETENTION_DAYS = 60;

// ============================================================================
// Paths
// ============================================================================

function getTasksDir(): string {
  const user = process.env.USER || process.env.LOGNAME || "unknown";
  const base = process.env.BESON_ROOT || process.cwd();
  return join(base, "workspace", "users", user, "tasks");
}

function getArchiveDir(yearMonth: string): string {
  return join(getTasksDir(), "archive", yearMonth);
}

function getUpdateLogPath(): string {
  return join(getTasksDir(), "_update-log.md");
}

// ============================================================================
// Utilities
// ============================================================================

function generateId(): string {
  return crypto.randomUUID().replace(/-/g, "").slice(0, 4);
}

function today(): string {
  return new Date().toISOString().split("T")[0];
}

function now(): string {
  return new Date().toISOString().split("T")[1].slice(0, 5);
}

function yearMonth(): string {
  return today().slice(0, 7);
}

async function ensureDir(dir: string): Promise<void> {
  if (!existsSync(dir)) {
    await mkdir(dir, { recursive: true });
  }
}

function output(data: unknown, json: boolean): void {
  if (json) {
    console.log(JSON.stringify(data, null, 2));
  } else if (typeof data === "string") {
    console.log(data);
  } else {
    console.log(JSON.stringify(data, null, 2));
  }
}

function error(message: string, code: string, details?: Record<string, unknown>): never {
  console.error(JSON.stringify({ error: message, code, ...details }));
  process.exit(1);
}

// ID validation to prevent path traversal
function validateId(id: string): void {
  if (!id || typeof id !== "string") {
    error("ID is required", "INVALID_ID");
  }
  // Only allow alphanumeric and hyphens, max 32 chars
  if (!/^[a-z0-9\-]{1,32}$/i.test(id)) {
    error("Invalid ID format (alphanumeric and hyphens only)", "INVALID_ID", { id });
  }
  // Explicitly block path traversal
  if (id.includes("..") || id.includes("/") || id.includes("\\")) {
    error("ID cannot contain path traversal sequences", "INVALID_ID", { id });
  }
}

// Cycle detection for dependency graph
async function wouldCreateCycle(taskId: string, newBlockerId: string): Promise<boolean> {
  const allTasks = await loadAllTasks(true);
  const taskMap = new Map(allTasks.map(t => [t.task.id, t.task]));
  
  // BFS from newBlockerId's blocked_by chain to see if we reach taskId
  const visited = new Set<string>();
  const queue = [newBlockerId];
  
  while (queue.length > 0) {
    const current = queue.shift()!;
    if (current === taskId) return true; // Cycle detected
    if (visited.has(current)) continue;
    visited.add(current);
    
    const task = taskMap.get(current);
    if (task?.blocked_by) {
      for (const blocker of task.blocked_by) {
        if (!visited.has(blocker)) {
          queue.push(blocker);
        }
      }
    }
  }
  return false;
}

// ============================================================================
// Task I/O
// ============================================================================

// Find a file by ID with flexible matching: {id}.md or {id}-*.md
async function findFileById(dir: string, id: string): Promise<string | null> {
  if (!existsSync(dir)) return null;
  
  const files = await readdir(dir);
  const match = files.find(f => 
    (f === `${id}.md`) || (f.startsWith(`${id}-`) && f.endsWith('.md'))
  );
  
  return match ? join(dir, match) : null;
}

async function loadTask(id: string, includeArchived = false): Promise<{ task: Task; path: string; content: string } | null> {
  validateId(id);
  const tasksDir = getTasksDir();
  
  // Try active tasks with flexible matching
  const activePath = await findFileById(tasksDir, id);
  if (activePath) {
    const raw = await readFile(activePath, "utf-8");
    const { data, content } = parseFrontmatter(raw);
    const task = TaskSchema.parse(data);
    return { task, path: activePath, content };
  }
  
  if (includeArchived) {
    const archiveBase = join(tasksDir, "archive");
    if (existsSync(archiveBase)) {
      const months = await readdir(archiveBase);
      for (const month of months) {
        const monthDir = join(archiveBase, month);
        const archivePath = await findFileById(monthDir, id);
        if (archivePath) {
          const raw = await readFile(archivePath, "utf-8");
          const { data, content } = parseFrontmatter(raw);
          const task = TaskSchema.parse(data);
          return { task, path: archivePath, content };
        }
      }
    }
  }
  
  return null;
}

async function saveTask(task: Task, content: string, path?: string): Promise<string> {
  const tasksDir = getTasksDir();
  await ensureDir(tasksDir);
  
  const filePath = path || join(tasksDir, `${task.id}.md`);
  const fileContent = matter.stringify(content, task);
  await writeFile(filePath, fileContent);
  return filePath;
}

async function loadAllTasks(includeArchived = false): Promise<Array<{ task: Task; path: string }>> {
  const tasksDir = getTasksDir();
  const tasks: Array<{ task: Task; path: string }> = [];
  
  if (!existsSync(tasksDir)) {
    return tasks;
  }
  
  // Load active tasks
  const files = await readdir(tasksDir);
  for (const file of files) {
    if (file.endsWith(".md") && !file.startsWith("_")) {
      const path = join(tasksDir, file);
      const raw = await readFile(path, "utf-8");
      const { data } = parseFrontmatter(raw);
      try {
        const task = TaskSchema.parse(data);
        tasks.push({ task, path });
      } catch {
        // Skip invalid files
      }
    }
  }
  
  // Load archived tasks
  if (includeArchived) {
    const archiveBase = join(tasksDir, "archive");
    if (existsSync(archiveBase)) {
      const months = await readdir(archiveBase);
      for (const month of months) {
        const monthDir = join(archiveBase, month);
        const archiveFiles = await readdir(monthDir);
        for (const file of archiveFiles) {
          if (file.endsWith(".md") && !file.startsWith("_")) {
            const path = join(monthDir, file);
            const raw = await readFile(path, "utf-8");
            const { data } = parseFrontmatter(raw);
            try {
              const task = TaskSchema.parse(data);
              tasks.push({ task, path });
            } catch {
              // Skip invalid files
            }
          }
        }
      }
    }
  }
  
  return tasks;
}

// ============================================================================
// Update Log
// ============================================================================

async function appendLog(taskId: string, title: string, message: string): Promise<void> {
  const logPath = getUpdateLogPath();
  await ensureDir(getTasksDir());
  
  const todayStr = today();
  const timeStr = now();
  const entry = `- **${timeStr}** ${message}\n`;
  const taskHeader = `### ${taskId}: ${title}\n`;
  const dateHeader = `## ${todayStr}\n\n`;
  
  let content = "";
  if (existsSync(logPath)) {
    content = await readFile(logPath, "utf-8");
  } else {
    content = "# Task Update Log\n\n";
  }
  
  if (!content.includes(dateHeader.trim())) {
    const titleEnd = content.indexOf("\n\n") + 2;
    content = content.slice(0, titleEnd) + dateHeader + content.slice(titleEnd);
  }
  
  const dateIndex = content.indexOf(dateHeader.trim());
  const nextDateIndex = content.indexOf("\n## ", dateIndex + 1);
  const sectionEnd = nextDateIndex === -1 ? content.length : nextDateIndex;
  const todaySection = content.slice(dateIndex, sectionEnd);
  if (todaySection.includes(taskHeader.trim())) {
    const taskIndex = content.indexOf(taskHeader.trim(), dateIndex);
    const taskEndIndex = content.indexOf("\n### ", taskIndex + 1);
    const insertPoint = taskEndIndex === -1 || taskEndIndex > sectionEnd ? sectionEnd : taskEndIndex;
    content = content.slice(0, insertPoint) + entry + content.slice(insertPoint);
  } else {
    const insertPoint = dateIndex + dateHeader.length;
    content = content.slice(0, insertPoint) + taskHeader + entry + "\n" + content.slice(insertPoint);
  }
  
  await writeFile(logPath, content);
}

// ============================================================================
// Commands
// ============================================================================

async function cmdAdd(args: string[]): Promise<void> {
  const { values, positionals } = parseArgs({
    args,
    options: {
      priority: { type: "string", short: "p", default: "P2" },
      due: { type: "string", short: "d" },
      project: { type: "string" },
      repo: { type: "string" },
      "blocked-by": { type: "string" },
      tags: { type: "string", short: "t" },
      json: { type: "boolean", default: false },
    },
    allowPositionals: true,
  });
  
  const title = positionals.join(" ");
  if (!title) {
    error("Title is required", "MISSING_TITLE");
  }
  
  const id = generateId();
  const todayStr = today();
  const user = process.env.USER || process.env.LOGNAME || "unknown";
  
  const blockedBy = values["blocked-by"]?.split(",").map(s => s.trim()).filter(Boolean) || [];
  const tags = values.tags?.split(",").map(s => s.trim()).filter(Boolean) || [];
  
  for (const blockerId of blockedBy) {
    validateId(blockerId);
    const blockerData = await loadTask(blockerId);
    if (!blockerData) {
      error("Blocker task not found", "BLOCKER_NOT_FOUND", { blocker_id: blockerId });
    }
    if (await wouldCreateCycle(id, blockerId)) {
      error("Adding this blocker would create a dependency cycle", "CYCLE_DETECTED", { blocker_id: blockerId });
    }
  }
  
  const status = blockedBy.length > 0 ? "blocked" : "inbox";
  
  const task: Task = {
    id,
    title,
    status,
    priority: values.priority as "P0" | "P1" | "P2" | "P3",
    created: todayStr,
    updated: todayStr,
    due: values.due || null,
    done: null,
    project: values.project || null,
    repo: values.repo || null,
    team: values.repo?.split("/")[1] || null,
    owner: user,
    assignees: [user],
    stakeholders: [],
    blocked_by: blockedBy,
    blocks: [],
    related: [],
    tags,
  };
  
  const content = `
## Description

[Add description]

## Acceptance Criteria

- [ ] Criterion 1

## Notes

[Add notes]

## Log

- ${todayStr} ${now()}: Created task
`;
  
  await saveTask(task, content.trim());
  await appendLog(id, title, "Created task");
  
  // Update blocking tasks
  for (const blockerId of blockedBy) {
    const blockerData = await loadTask(blockerId);
    if (blockerData) {
      blockerData.task.blocks = [...(blockerData.task.blocks || []), id];
      blockerData.task.updated = todayStr;
      await saveTask(blockerData.task, blockerData.content, blockerData.path);
    }
  }
  
  output({ success: true, operation: "add", task }, values.json);
}

async function cmdShow(args: string[]): Promise<void> {
  const { values, positionals } = parseArgs({
    args,
    options: {
      json: { type: "boolean", default: false },
    },
    allowPositionals: true,
  });
  
  const id = positionals[0];
  if (!id) {
    error("Task ID is required", "MISSING_ID");
  }
  
  const data = await loadTask(id, true);
  if (!data) {
    error("Task not found", "TASK_NOT_FOUND", { id });
  }
  
  if (values.json) {
    output({ success: true, operation: "show", task: data.task }, true);
  } else {
    const raw = await readFile(data.path, "utf-8");
    console.log(raw);
  }
}

async function cmdList(args: string[]): Promise<void> {
  const { values } = parseArgs({
    args,
    options: {
      status: { type: "string" },
      priority: { type: "string" },
      project: { type: "string" },
      blocked: { type: "boolean", default: false },
      due: { type: "string" },
      tags: { type: "string", short: "t" },
      "include-archived": { type: "boolean", default: false },
      json: { type: "boolean", default: false },
    },
    allowPositionals: true,
  });
  
  let tasks = await loadAllTasks(values["include-archived"]);
  
  if (values.status) {
    tasks = tasks.filter(t => t.task.status === values.status);
  } else if (!values["include-archived"]) {
    tasks = tasks.filter(t => !["done", "cancelled"].includes(t.task.status));
  }
  
  if (values.priority) {
    tasks = tasks.filter(t => t.task.priority === values.priority);
  }
  
  if (values.project) {
    tasks = tasks.filter(t => t.task.project === values.project);
  }
  
  if (values.blocked) {
    tasks = tasks.filter(t => t.task.status === "blocked");
  }
  
  if (values.due) {
    const todayStr = today();
    if (values.due === "today") {
      tasks = tasks.filter(t => t.task.due === todayStr);
    } else if (values.due === "this-week") {
      const weekEnd = new Date();
      weekEnd.setDate(weekEnd.getDate() + (7 - weekEnd.getDay()));
      const weekEndStr = weekEnd.toISOString().split("T")[0];
      tasks = tasks.filter(t => t.task.due && t.task.due <= weekEndStr);
    }
  }
  
  if (values.tags) {
    const filterTags = values.tags.split(",").map(s => s.trim()).filter(Boolean);
    tasks = tasks.filter(t => 
      filterTags.some(tag => t.task.tags?.includes(tag))
    );
  }
  
  const priorityOrder = { P0: 0, P1: 1, P2: 2, P3: 3 };
  tasks.sort((a, b) => {
    const pDiff = priorityOrder[a.task.priority] - priorityOrder[b.task.priority];
    if (pDiff !== 0) return pDiff;
    if (a.task.due && b.task.due) return a.task.due.localeCompare(b.task.due);
    if (a.task.due) return -1;
    if (b.task.due) return 1;
    return 0;
  });
  
  if (values.json) {
    output({ success: true, operation: "list", count: tasks.length, tasks: tasks.map(t => t.task) }, true);
  } else {
    if (tasks.length === 0) {
      console.log("No tasks found");
    } else {
      for (const { task } of tasks) {
        const dueStr = task.due ? ` (due: ${task.due})` : "";
        const blockedStr = task.status === "blocked" ? " [BLOCKED]" : "";
        console.log(`${task.id} [${task.priority}] ${task.title}${dueStr}${blockedStr}`);
      }
    }
  }
}

async function cmdDone(args: string[]): Promise<void> {
  const { values, positionals } = parseArgs({
    args,
    options: {
      json: { type: "boolean", default: false },
    },
    allowPositionals: true,
  });
  
  const id = positionals[0];
  if (!id) {
    error("Task ID is required", "MISSING_ID");
  }
  
  const data = await loadTask(id);
  if (!data) {
    error("Task not found", "TASK_NOT_FOUND", { id });
  }
  
  const todayStr = today();
  const oldStatus = data.task.status;
  data.task.status = "done";
  data.task.done = todayStr;
  data.task.updated = todayStr;
  
  await saveTask(data.task, data.content, data.path);
  await appendLog(id, data.task.title, `Status: ${oldStatus} -> done`);
  
  // Unblock dependent tasks
  const allTasks = await loadAllTasks();
  for (const { task, path } of allTasks) {
    if (task.blocked_by?.includes(id)) {
      task.blocked_by = task.blocked_by.filter(b => b !== id);
      task.updated = todayStr;
      
      if (task.blocked_by.length === 0 && task.status === "blocked") {
        task.status = "active";
        await appendLog(task.id, task.title, `Unblocked by completion of ${id}`);
      }
      
      const raw = await readFile(path, "utf-8");
      const { content } = parseFrontmatter(raw);
      await saveTask(task, content, path);
    }
  }
  
  output({ success: true, operation: "done", task: data.task }, values.json);
}

async function cmdCancel(args: string[]): Promise<void> {
  const { values, positionals } = parseArgs({
    args,
    options: {
      reason: { type: "string", short: "r" },
      json: { type: "boolean", default: false },
    },
    allowPositionals: true,
  });
  
  const id = positionals[0];
  if (!id) {
    error("Task ID is required", "MISSING_ID");
  }
  
  const data = await loadTask(id);
  if (!data) {
    error("Task not found", "TASK_NOT_FOUND", { id });
  }
  
  const todayStr = today();
  const oldStatus = data.task.status;
  data.task.status = "cancelled";
  data.task.updated = todayStr;
  
  await saveTask(data.task, data.content, data.path);
  const reason = values.reason ? ` (${values.reason})` : "";
  await appendLog(id, data.task.title, `Status: ${oldStatus} -> cancelled${reason}`);
  
  output({ success: true, operation: "cancel", task: data.task }, values.json);
}

async function cmdBlocked(args: string[]): Promise<void> {
  const { values } = parseArgs({
    args,
    options: {
      json: { type: "boolean", default: false },
    },
    allowPositionals: true,
  });
  
  const tasks = await loadAllTasks();
  const blocked = tasks.filter(t => t.task.status === "blocked");
  
  if (values.json) {
    output({ success: true, operation: "blocked", count: blocked.length, tasks: blocked.map(t => t.task) }, true);
  } else {
    if (blocked.length === 0) {
      console.log("No blocked tasks");
    } else {
      for (const { task } of blocked) {
        const blockers = task.blocked_by?.join(", ") || "unknown";
        console.log(`${task.id} [${task.priority}] ${task.title} (blocked by: ${blockers})`);
      }
    }
  }
}

async function cmdDeps(args: string[]): Promise<void> {
  const { values, positionals } = parseArgs({
    args,
    options: {
      "blocked-by": { type: "boolean", default: false },
      blocks: { type: "boolean", default: false },
      json: { type: "boolean", default: false },
    },
    allowPositionals: true,
  });
  
  const id = positionals[0];
  if (!id) {
    error("Task ID is required", "MISSING_ID");
  }
  
  const data = await loadTask(id, true);
  if (!data) {
    error("Task not found", "TASK_NOT_FOUND", { id });
  }
  
  const allTasks = await loadAllTasks(true);
  const taskMap = new Map(allTasks.map(t => [t.task.id, t.task]));
  
  const blockedByTasks = (data.task.blocked_by || []).map(bid => taskMap.get(bid)).filter(Boolean);
  const blocksTasks = (data.task.blocks || []).map(bid => taskMap.get(bid)).filter(Boolean);
  
  if (values.json) {
    const result: Record<string, unknown> = {
      success: true,
      operation: "deps",
      task_id: id,
      title: data.task.title,
      status: data.task.status,
    };
    
    if (!values.blocks) {
      result.blocked_by = blockedByTasks;
    }
    if (!values["blocked-by"]) {
      result.blocks = blocksTasks;
    }
    
    output(result, true);
  } else {
    console.log(`${id}: ${data.task.title} [${data.task.status}]`);
    
    if (!values.blocks && blockedByTasks.length > 0) {
      console.log("├── blocked_by:");
      for (const t of blockedByTasks) {
        console.log(`│   └── ${t!.id}: ${t!.title} [${t!.status}]`);
      }
    }
    
    if (!values["blocked-by"] && blocksTasks.length > 0) {
      console.log("└── blocks:");
      for (const t of blocksTasks) {
        console.log(`    └── ${t!.id}: ${t!.title} [${t!.status}]`);
      }
    }
    
    if (blockedByTasks.length === 0 && blocksTasks.length === 0) {
      console.log("No dependencies");
    }
  }
}

async function cmdUnblock(args: string[]): Promise<void> {
  const { values, positionals } = parseArgs({
    args,
    options: {
      json: { type: "boolean", default: false },
    },
    allowPositionals: true,
  });
  
  const id = positionals[0];
  if (!id) {
    error("Task ID is required", "MISSING_ID");
  }
  
  const data = await loadTask(id);
  if (!data) {
    error("Task not found", "TASK_NOT_FOUND", { id });
  }
  
  if (data.task.status !== "blocked") {
    error("Task is not blocked", "NOT_BLOCKED", { id, status: data.task.status });
  }
  
  const todayStr = today();
  data.task.blocked_by = [];
  data.task.status = "active";
  data.task.updated = todayStr;
  
  await saveTask(data.task, data.content, data.path);
  await appendLog(id, data.task.title, "Manually unblocked, status: blocked -> active");
  
  output({ success: true, operation: "unblock", task: data.task }, values.json);
}

async function cmdArchive(args: string[]): Promise<void> {
  const { values, positionals } = parseArgs({
    args,
    options: {
      "dry-run": { type: "boolean", default: false },
      "older-than": { type: "string" },
      json: { type: "boolean", default: false },
    },
    allowPositionals: true,
  });
  
  const specificId = positionals[0];
  const todayStr = today();
  const ym = yearMonth();
  
  let toArchive: Array<{ task: Task; path: string }> = [];
  
  if (specificId) {
    const data = await loadTask(specificId);
    if (!data) {
      error("Task not found", "TASK_NOT_FOUND", { id: specificId });
    }
    if (!["done", "cancelled"].includes(data.task.status)) {
      error("Only done or cancelled tasks can be archived", "INVALID_STATUS", { status: data.task.status });
    }
    toArchive = [{ task: data.task, path: data.path }];
  } else {
    const tasks = await loadAllTasks();
    const daysThreshold = values["older-than"]
      ? parseInt(values["older-than"].replace("d", ""))
      : TASK_ARCHIVE_RETENTION_DAYS;
    
    const cutoff = new Date();
    cutoff.setDate(cutoff.getDate() - daysThreshold);
    const cutoffStr = cutoff.toISOString().split("T")[0];
    
    toArchive = tasks.filter(({ task }) => {
      if (!["done", "cancelled"].includes(task.status)) return false;
      const doneDate = task.done || task.updated;
      return doneDate && doneDate <= cutoffStr;
    });
  }
  
  if (values["dry-run"]) {
    output({
      success: true,
      operation: "archive",
      dry_run: true,
      count: toArchive.length,
      tasks: toArchive.map(t => ({ id: t.task.id, title: t.task.title, status: t.task.status })),
    }, values.json);
    return;
  }
  
  const archiveDir = getArchiveDir(ym);
  await ensureDir(archiveDir);
  
  for (const { task, path } of toArchive) {
    task.archived = todayStr;
    task.updated = todayStr;
    
    const raw = await readFile(path, "utf-8");
    const { content } = parseFrontmatter(raw);
    
    const newPath = join(archiveDir, basename(path));
    await saveTask(task, content, newPath);
    await unlink(path);
    await appendLog(task.id, task.title, `Archived to ${ym}`);
  }
  
  output({
    success: true,
    operation: "archive",
    count: toArchive.length,
    tasks: toArchive.map(t => ({ id: t.task.id, title: t.task.title })),
  }, values.json);
}

async function cmdUnarchive(args: string[]): Promise<void> {
  const { values, positionals } = parseArgs({
    args,
    options: {
      json: { type: "boolean", default: false },
    },
    allowPositionals: true,
  });
  
  const id = positionals[0];
  if (!id) {
    error("Task ID is required", "MISSING_ID");
  }
  
  const data = await loadTask(id, true);
  if (!data) {
    error("Task not found", "TASK_NOT_FOUND", { id });
  }
  
  if (!data.path.includes("/archive/")) {
    error("Task is not archived", "NOT_ARCHIVED", { id });
  }
  
  const todayStr = today();
  data.task.archived = null;
  data.task.status = "active";
  data.task.updated = todayStr;
  
  const tasksDir = getTasksDir();
  const newPath = join(tasksDir, `${id}.md`);
  
  const raw = await readFile(data.path, "utf-8");
  const { content } = parseFrontmatter(raw);
  
  await saveTask(data.task, content, newPath);
  await unlink(data.path);
  await appendLog(id, data.task.title, "Unarchived, status: -> active");
  
  output({ success: true, operation: "unarchive", task: data.task }, values.json);
}

async function cmdLog(args: string[]): Promise<void> {
  const { values, positionals } = parseArgs({
    args,
    options: {
      since: { type: "string" },
      json: { type: "boolean", default: false },
    },
    allowPositionals: true,
  });
  
  const logPath = getUpdateLogPath();
  
  if (!existsSync(logPath)) {
    output({ success: true, operation: "log", entries: [] }, values.json);
    return;
  }
  
  const content = await readFile(logPath, "utf-8");
  
  const specificId = positionals[0];
  if (specificId) {
    const lines = content.split("\n");
    const filtered: string[] = [];
    let inTask = false;
    
    for (const line of lines) {
      if (line.startsWith("### ")) {
        inTask = line.includes(specificId);
      }
      if (inTask || line.startsWith("# ") || line.startsWith("## ")) {
        filtered.push(line);
      }
    }
    
    console.log(filtered.join("\n"));
  } else {
    console.log(content);
  }
}

async function cmdPublish(args: string[]): Promise<void> {
  const { values, positionals } = parseArgs({
    args,
    options: {
      json: { type: "boolean", default: false },
    },
    allowPositionals: true,
  });
  
  const id = positionals[0];
  if (!id) {
    error("Task ID is required", "MISSING_ID");
  }
  
  const data = await loadTask(id);
  if (!data) {
    error("Task not found", "TASK_NOT_FOUND", { id });
  }
  
  const user = process.env.USER || process.env.LOGNAME || "unknown";
  const base = process.env.BESON_ROOT || process.cwd();
  const publicTasksDir = join(base, "workspace", "users", user, "public", "tasks");
  await ensureDir(publicTasksDir);
  
  const publicPath = join(publicTasksDir, `${id}.md`);
  const raw = await readFile(data.path, "utf-8");
  await writeFile(publicPath, raw);
  
  await appendLog(id, data.task.title, "Published to public/tasks/");
  
  output({ success: true, operation: "publish", task: data.task, public_path: publicPath }, values.json);
}

async function cmdUnpublish(args: string[]): Promise<void> {
  const { values, positionals } = parseArgs({
    args,
    options: {
      json: { type: "boolean", default: false },
    },
    allowPositionals: true,
  });
  
  const id = positionals[0];
  if (!id) {
    error("Task ID is required", "MISSING_ID");
  }
  
  const user = process.env.USER || process.env.LOGNAME || "unknown";
  const base = process.env.BESON_ROOT || process.cwd();
  const publicPath = join(base, "workspace", "users", user, "public", "tasks", `${id}.md`);
  
  if (!existsSync(publicPath)) {
    error("Task is not published", "NOT_PUBLISHED", { id });
  }
  
  await unlink(publicPath);
  
  const data = await loadTask(id);
  if (data) {
    await appendLog(id, data.task.title, "Unpublished from public/tasks/");
  }
  
  output({ success: true, operation: "unpublish", id }, values.json);
}

async function cmdEdit(args: string[]): Promise<void> {
  const { values, positionals } = parseArgs({
    args,
    options: {
      json: { type: "boolean", default: false },
    },
    allowPositionals: true,
  });
  
  const id = positionals[0];
  if (!id) {
    error("Task ID is required", "MISSING_ID");
  }
  
  const data = await loadTask(id);
  if (!data) {
    error("Task not found", "TASK_NOT_FOUND", { id });
  }
  
  const editor = process.env.EDITOR || process.env.VISUAL || "vi";
  const { spawn: spawnSync } = await import("child_process");
  
  const proc = spawnSync(editor, [data.path], { 
    stdio: "inherit",
    env: process.env,
  });
  
  await new Promise<void>((resolve, reject) => {
    proc.on("close", (code) => {
      code === 0 ? resolve() : reject(new Error(`Editor exited with code ${code}`));
    });
    proc.on("error", reject);
  });
  
  const editedData = await loadTask(id);
  if (!editedData) {
    error("Task file was deleted during edit", "EDIT_ERROR", { id });
  }
  
  await appendLog(id, editedData.task.title, "Edited via editor");
  
  if (values.json) {
    output({ success: true, operation: "edit", task: editedData.task }, true);
  } else {
    console.log(`Task ${id} updated successfully`);
  }
}

// ============================================================================
// Lint
// ============================================================================

interface LintIssue {
  file: string;
  id: string;
  severity: "error" | "warning";
  code: string;
  message: string;
  line?: number;
}

async function lintTaskFile(filePath: string): Promise<LintIssue[]> {
  const issues: LintIssue[] = [];
  const fileName = basename(filePath);
  
  let raw: string;
  try {
    raw = await readFile(filePath, "utf-8");
  } catch {
    return [{ file: fileName, id: "unknown", severity: "error", code: "READ_ERROR", message: "Could not read file" }];
  }
  
  // Extract frontmatter section
  const fmMatch = raw.match(/^---\n([\s\S]*?)\n---/);
  if (!fmMatch) {
    return [{ file: fileName, id: "unknown", severity: "error", code: "NO_FRONTMATTER", message: "No frontmatter found" }];
  }
  const fmContent = fmMatch[1];
  const fmLines = fmContent.split("\n");
  
  // Check for duplicate keys
  const keyLines: Record<string, number[]> = {};
  fmLines.forEach((line, idx) => {
    const keyMatch = line.match(/^([a-z_]+):/);
    if (keyMatch) {
      const key = keyMatch[1];
      if (!keyLines[key]) keyLines[key] = [];
      keyLines[key].push(idx + 2); // +2 for 1-indexed and opening ---
    }
  });
  
  for (const [key, lines] of Object.entries(keyLines)) {
    if (lines.length > 1) {
      issues.push({
        file: fileName,
        id: "unknown",
        severity: "error",
        code: "DUPLICATE_KEY",
        message: `Duplicate key '${key}' at lines ${lines.join(", ")}`,
        line: lines[1],
      });
    }
  }
  
  // If duplicate keys exist, can't parse further
  if (issues.some(i => i.code === "DUPLICATE_KEY")) {
    return issues;
  }
  
  // Parse and validate
  let data: Record<string, unknown>;
  try {
    const parsed = parseFrontmatter(raw);
    data = parsed.data as Record<string, unknown>;
  } catch (e) {
    return [...issues, { file: fileName, id: "unknown", severity: "error", code: "YAML_PARSE", message: `YAML parse error: ${e}` }];
  }
  
  const id = typeof data.id === "string" ? data.id : "unknown";
  
  // Check for numeric values in ID arrays (blocked_by, blocks, related)
  for (const field of ["blocked_by", "blocks", "related"]) {
    const arr = data[field];
    if (Array.isArray(arr)) {
      arr.forEach((val, idx) => {
        if (typeof val === "number") {
          issues.push({
            file: fileName,
            id,
            severity: "error",
            code: "NUMERIC_ID",
            message: `${field}[${idx}] is a number (${val}), should be quoted string '${val}'`,
          });
        }
      });
    }
  }
  
  // Validate against schema
  const result = TaskSchema.safeParse(data);
  if (!result.success) {
    for (const err of result.error.errors) {
      issues.push({
        file: fileName,
        id,
        severity: "error",
        code: "SCHEMA_ERROR",
        message: `${err.path.join(".")}: ${err.message}`,
      });
    }
  }
  
  return issues;
}

async function lintAllTasks(): Promise<{ issues: LintIssue[]; fileCount: number }> {
  const tasksDir = getTasksDir();
  const issues: LintIssue[] = [];
  let fileCount = 0;
  
  if (!existsSync(tasksDir)) {
    return { issues, fileCount };
  }
  
  const files = await readdir(tasksDir);
  for (const file of files) {
    if (file.endsWith(".md") && !file.startsWith("_")) {
      fileCount++;
      const filePath = join(tasksDir, file);
      const fileIssues = await lintTaskFile(filePath);
      issues.push(...fileIssues);
    }
  }
  
  return { issues, fileCount };
}

async function cmdLint(args: string[]): Promise<void> {
  const { values, positionals } = parseArgs({
    args,
    options: {
      json: { type: "boolean", default: false },
      fix: { type: "boolean", default: false },
    },
    allowPositionals: true,
  });
  
  const specificId = positionals[0];
  
  if (specificId) {
    // Lint single task
    validateId(specificId);
    const tasksDir = getTasksDir();
    const filePath = await findFileById(tasksDir, specificId);
    
    if (!filePath) {
      error("Task not found", "TASK_NOT_FOUND", { id: specificId });
    }
    
    const issues = await lintTaskFile(filePath);
    
    if (values.json) {
      output({ success: issues.length === 0, issues, fileCount: 1 }, true);
    } else {
      if (issues.length === 0) {
        console.log(`✓ ${specificId}: No issues found`);
      } else {
        for (const issue of issues) {
          const prefix = issue.severity === "error" ? "✗" : "⚠";
          console.log(`${prefix} ${issue.id}: [${issue.code}] ${issue.message}`);
        }
      }
    }
    
    if (issues.some(i => i.severity === "error")) {
      process.exit(1);
    }
    return;
  }
  
  // Lint all tasks
  const { issues, fileCount } = await lintAllTasks();
  const errors = issues.filter(i => i.severity === "error");
  const warnings = issues.filter(i => i.severity === "warning");
  
  if (values.json) {
    output({ success: errors.length === 0, issues, fileCount, errorCount: errors.length, warningCount: warnings.length }, true);
  } else {
    if (issues.length === 0) {
      console.log(`✓ All ${fileCount} tasks valid`);
    } else {
      for (const issue of issues) {
        const prefix = issue.severity === "error" ? "✗" : "⚠";
        const lineInfo = issue.line ? `:${issue.line}` : "";
        console.log(`${prefix} ${issue.file}${lineInfo}: [${issue.code}] ${issue.message}`);
      }
      console.log(`\n${errors.length} error(s), ${warnings.length} warning(s) in ${fileCount} files`);
    }
  }
  
  if (errors.length > 0) {
    process.exit(1);
  }
}

// ============================================================================
// Main
// ============================================================================

const commands: Record<string, (args: string[]) => Promise<void>> = {
  add: cmdAdd,
  lint: cmdLint,
  show: cmdShow,
  edit: cmdEdit,
  list: cmdList,
  done: cmdDone,
  cancel: cmdCancel,
  blocked: cmdBlocked,
  deps: cmdDeps,
  unblock: cmdUnblock,
  archive: cmdArchive,
  unarchive: cmdUnarchive,
  log: cmdLog,
  publish: cmdPublish,
  unpublish: cmdUnpublish,
};

async function main(): Promise<void> {
  const args = process.argv.slice(2);
  const command = args[0];
  
  if (!command || command === "help" || command === "--help") {
    console.log(`qt - Task tracking CLI for Q agent

Usage: qt <command> [options]

Commands:
  add <title>     Create a new task
  show <id>       Show task details
  edit <id>       Edit task in $EDITOR
  list            List tasks
  done <id>       Mark task as done
  cancel <id>     Cancel a task
  blocked         Show blocked tasks
  deps <id>       Show task dependencies
  unblock <id>    Clear task blockers
  archive [id]    Archive completed tasks
  unarchive <id>  Restore archived task
  log [id]        Show update log
  publish <id>    Publish to public/
  unpublish <id>  Remove from public/
  lint [id]       Validate task files

Options:
  --json          Output as JSON
  --help          Show help

Examples:
  qt add "Deploy service" -p P0 -d 2026-01-15 -t deploy,prod
  qt list --status active --priority P0
  qt done a3f9
  qt blocked
  qt lint            # Lint all tasks
  qt lint a3f9       # Lint specific task
  qt archive --dry-run
`);
    return;
  }
  
  const handler = commands[command];
  if (!handler) {
    error(`Unknown command: ${command}`, "UNKNOWN_COMMAND", { command });
  }
  
  await handler(args.slice(1));
}

main().catch(err => {
  console.error(JSON.stringify({ error: err.message, code: "INTERNAL_ERROR" }));
  process.exit(1);
});
